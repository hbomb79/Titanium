--[[
    @instance propertyValues - table (def. {}) - The values of all watched properties, passed to the equation when solving the dynamic value equation
    @instance properties - table (def. {}) - The properties being watched by this DynamicValue
    @instance target - Instance (def. nil) - The Titanium instance that the DynamicValue belongs to. When re-solved, the 'property' is updated on this target to become the new value of the equation
    @instance property - string (def. nil) - The property that the DynamicValue is responsible for updating on 'target'
    @instance equation - string (def. nil) - The Lua equation that will be solved to find the value for 'property' on 'target'

    A dynamic value object is used by MPropertyManager (primarily) to link properties to an equation.

    When instantiated, the DynamicValue object automatically creates watch instructions on the properties provided via 'properties'.
    Anytime one of the watched properties changes, the DynamicValue is updated and the equation provided is re-solved, with the new
    property values provided.

    This allows for equations dependent on other instances to become dynamic, changing with their target instances.
]]

class DynamicValue {
    propertyValues = {};
    properties = {};
}

--[[
    @constructor
    @desc Creates watcher instructions towards 'target' for each property linked
    @param <Instance - target>, <string - property>, <table - properties>, <string - equation>
]]
function DynamicValue:__init__( ... )
    self:resolve( ... )
    self:attach()

    local reg = Titanium.getClass( self.target.__type ):getRegistry().constructor
    if reg and reg.argumentTypes then
        self.type = reg.argumentTypes[ self.property ]
    end

    self:solve()
end

--[[
    @instance
    @desc Attach watch instructions to each required argument
]]
function DynamicValue:attach()
    local properties = self.properties
    for i = 1, #properties do
        local obj, prop = properties[ i ][ 2 ], properties[ i ][ 1 ]

        obj:watchProperty( prop, function( _, __, val )
            self.propertyValues[ i ] = val
            self:solve()
        end, "DYNAMIC_LINK_" .. self.__ID )

        self.propertyValues[ i ] = obj[ prop ]
    end
end

--[[
    @instance
    @desc Detaches the watcher instructions towards the targets of the dynamic value
]]
function DynamicValue:detach()
    local properties = self.properties
    for i = 1, #properties do
        local prop = properties[ i ]
        prop[ 2 ]:unwatchProperty( prop[ 1 ], "DYNAMIC_LINK_" .. self.__ID )
    end
end

--[[
    @instance
    @desc Solves the 'equation' by inserting the values fetched off of linked targets
]]
function DynamicValue:solve()
    local fn, err = loadstring( self.equation )
    if not fn then return error("Failed to solve dynamic value equation ("..tostring( eq ).."). Parse exception: " .. tostring( err )) end

    local ok, val = pcall( fn, self.propertyValues )
    if not ok then return error("Failed to solve dyamic value equation ("..tostring( eq ).."). Runtime exception: " .. tostring( val )) end

    self.target[ self.property ] = XMLParser.convertArgType( val, self.type )
end

configureConstructor {
    orderedArguments = { "target", "property", "properties", "equation" },
    argumentTypes = {
        property = "string",
        properties = "table",
        equation = "string"
    },
    requiredArguments = true
}
