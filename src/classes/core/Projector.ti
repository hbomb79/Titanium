--[[
    WIP
]]

class Projector extends Component {
    static = {
        modes = {}
    };

    application = false;

    target = false;
    mode = false;
    mirrors = {};

    name = false;
}

--[[
    @constructor
    @desc Instantiates the Projector instance, resolves properties and creates a blank Canvas.
]]
function Projector:__init__( ... )
    self:resolve( ... )

    self.canvas = TermCanvas( self )
end

--[[
    @instance
    @desc
]]
function Projector:updateDisplay()
    if not self.mode then
        return error "Failed to update projector display. No mode has been set on the Projector"
    elseif not self.target then
        return error "Failed to update projector display. No target has been set on the Projector"
    end

    local mode = Projector.static.modes[ self.mode ]
    if not self.resolvedTarget then
        self.resolvedTarget = mode.targetResolver and mode.targetResolver( self, self.target ) or self.target
    end

    mode.draw( self )
end

function Projector:handleEvent( eventObj )
    if not self.mode then
        return error "Failed to handle event. No mode has been set on the Projector"
    end

    local eventDispatcher = Projector.static.modes[ self.mode ].eventDispatcher
    if eventDispatcher then
        eventDispatcher( self, eventObj )
    end
end

--[[
    @setter
    @desc Sets the target of the projector after checking the type is correct
    @param <Any - target>
]]
function Projector:setTarget( target )
    self.target = target
    self.resolvedTarget = nil
end

--[[
    @instance
    @desc Attaches a mirror (MProjectable mixer) to the Projector
    @param <Instance - mirror>
]]
function Projector:attachMirror( mirror )
    local mirrors = self.mirrors
    for i = 1, #mirrors do
        if mirrors[ i ] == mirror then return end
    end

    mirrors[ #mirrors + 1 ] = mirror
end

--[[
    @instance
    @desc Removes the mirror from the Projector
    @param <Instance - mirror>
    @return <Instance - removedMirror> - If a mirror is removed it is returned
]]
function Projector:detachMirror( mirror )
    local mirrors = self.mirrors
    for i = 1, #mirrors do
        if mirrors[ i ] == mirror then
            return table.remove( mirrors, i )
        end
    end
end

--[[
    @setter
    @desc Sets the mode of the projector and resets the resolved target
    @param <string - mode>
]]
function Projector:setMode( mode )
    local md = Projector.modes[ mode ]
    if not md then
        return error("Projector mode '"..tostring( mode ).." is invalid (doesn't exist)")
    end

    self.mode = mode
    self.resolvedTarget = nil

    md.init( self )
end

--[[
    @static
    @desc Registers a projector mode. The given argumentTypes are used when setting variable to ensure valid data is provided.

          The drawFunction is called, and has access to the current buffer. This buffer can then be 'drawn' using any method, such as
          monitor draw functions, rednet, etc...

          The 'config' table MUST contain 'draw (function)' and 'argumentTypes (table)' keys.
    @param <table - config>
]]
function Projector.static.registerMode( config )
    if not type( config ) == "table" then
        return error "Failed to register projector mode. Expected argument table (config)"
    elseif not ( type( config.init ) == "function" and type( config.mode ) == "string" and type( config.draw ) == "function" ) then
        return error "Failed to register projector mode. Expected config table to contain 'init (function)', 'mode (string)' and 'draw (function)' keys"
    elseif Projector.modes[ mode ] then
        return error( "Failed to register projector mode. Mode '"..tostring( mode ) .."' has already been registered" )
    end

    Projector.modes[ config.mode ] = config
end

configureConstructor( {
    orderedArguments = { "name", "mode", "target" },
    requiredArguments = true,
    argumentTypes = {
        name = "string",
        mode = "string"
    },
    useProxy = { "mode" }
}, true )