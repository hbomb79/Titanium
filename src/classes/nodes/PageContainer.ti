--[[
    The PageContainer serves as a container that shows one 'page' at a time. Preset (or completely custom) animated transitions can be used when
    a new page is selected.
]]

class PageContainer extends Container {
    scroll = 0;

    animationDuration = 0.25;
    animationEasing = "outQuad";
    customAnimation = false;
    selectedPage = false;

    pageIndexes = {};
}

--[[
    @instance
    @desc Intercepts the draw call, adding the x scroll to the x offset
    @param [boolean - force], [number - offsetX], [number - offsetY]
]]
function PageContainer:draw( force, offsetX, offsetY )
    return self.super:draw( force, ( offsetX or 0 ) - self.scroll, offsetY )
end

--[[
    @instance
    @desc If a MOUSE event is handled, it's X co-ordinate is adjusted using the scroll offset of the page container.
    @param <Event Instance - eventObj>
    @return <boolean - propagate>
]]
function PageContainer:handle( eventObj )
    if not self.super.super:handle( eventObj ) then return end

    local clone
    if eventObj.main == "MOUSE" then
        clone = eventObj:clone( self )
        clone.X = clone.X + self.scroll
        clone.isWithin = clone.isWithin and eventObj:withinParent( self ) or false
    end

    self:shipEvent( clone or eventObj )
    if clone and clone.isWithin and ( self.consumeAll or clone.handled ) then
        eventObj.handled = true
    end
    return true
end

--[[
    @instance
    @desc Selects the new page using the 'pageID'. If a function is given as argument #2 'animationOverride', it will be called instead of the customAnimation set (or the default animation method used).
          Therefore the animationOverride is given full control of the transition, allowing for easy one-off transition effects.

          If 'customAnimation' is set on the instance, it will be called if no 'animationOverride' is provided, providing a more long term override method.

          If neither are provided, a normal animation will take place, using 'animationDuration' and 'animationEasing' set on the instance as parameters for the animation.
    @param <string - pageID>, [function - animationOverride]
]]
function PageContainer:selectPage( pageID, animationOverride )
    local page = self:getPage( pageID )

    self.selectedPage = page
    if type( animationOverride ) == "function" then
        return animationOverride( self.currentPage, page )
    elseif self.customAnimation then
        return self.customAnimation( self.currentPage, page )
    end

    self:animate( self.__ID .. "_PAGE_CONTAINER_SELECTION", "scroll", ( self:getPagePosition( pageID ) - 1 ) * self.width, self.animationDuration, self.animationEasing )
end

--[[
    @instance
    @desc Returns an integer representing the position of the page. These may change as pages are added and removed from the PageContainer - don't rely on them remaining constant
    @param <string - pageID>
    @return <number - position>
]]
function PageContainer:getPagePosition( pageID )
    local indexes = self.pageIndexes
    for i = 1, #indexes do
        if indexes[ i ] == pageID then
            return i
        end
    end
end

--[[
    @instance
    @desc Ensures the node being added to the PageContainer is a 'Page' node because no other nodes should be added directly to this node
    @param <Page Instance - node>
    @return 'param1 (node)'
]]
function PageContainer:addNode( node )
    if Titanium.typeOf( node, "Page", true ) then
        local pgInd = self.pageIndexes
        if self:getPagePosition( node.id ) then
            return error("Cannot add page '"..tostring( node ).."'. Another page with the same ID already exists inside this PageContainer")
        end

        pgInd[ #pgInd + 1 ] = node.id
        node.X = ( #pgInd - 1 ) * self.width + 1

        return self.super:addNode( node )
    end

    return error("Only 'Page' nodes can be added as direct children of 'PageContainer' nodes, '"..tostring( node ).."' is invalid")
end

--[[
    @instance
    @desc A alias for 'addNode', contextualized for the PageContainer
    @param <Page Instance - page>
    @return 'param1 (page)'
]]
function PageContainer:addPage( page )
    return self:addNode( page )
end

--[[
    @instance
    @desc A alias for 'getNode', contextualized for the PageContainer
    @param <string - id>, [boolean - recursive]
    @return [Node Instance - node]
]]
function PageContainer:getPage( ... )
    return self:getNode( ... )
end

--[[
    @instance
    @desc A alias for 'removeNode', contextualized for the PageContainer
    @param <Node Instance | string - id>
    @return <boolean - success>, [node - removedNode]
]]
function PageContainer:removePage( ... )
    return self:removeNode( ... )
end

--[[
    @instance
    @desc Shifts requests to clear the PageContainer area to the left, depending on the scroll position of the container
    @param <number - x>, <number - y>, <number - width>, <number - height>
]]
function PageContainer:redrawArea( x, y, width, height )
    self.super:redrawArea( x, y, width, height, -self.scroll )
end

--[[
    @instance
    @desc Due to the contents of the PageContainer not actually moving (just the scroll), the content of the PageContainer must be manually cleared.
          To fit this demand, the area of the PageContainer is cleared when the scroll parameter is changed.
]]
function PageContainer:setScroll( scroll )
    self.scroll = scroll
    self:redrawArea( 1, 1, self.width, self.height )
end
