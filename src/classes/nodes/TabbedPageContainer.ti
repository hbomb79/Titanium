local function spawnScrollButton( text, forward, parent )
    local b = Button( text ):set { width = 1, enabled = "$self.visible" }

    b:on("trigger", function( self )
        parent:moveTabs( ( forward and -1 or 1 ) * ( parent.width / 2 ) )
    end):addClass "scroller"

    return parent.super.super:addNode( b )
end

class TabbedPageContainer extends PageContainer {
    cache = {};
    tabHeight = 1;
    smartTabWidth = true;
    scrollButtons = true;

    tabPadding = 1;
    tabScroll = 0;

    tabColour = 1;
    tabBackgroundColour = colours.lightBlue;

    selectedTabColour = 1;
    selectedTabBackgroundColour = colours.cyan;
}

function TabbedPageContainer:__init__( ... )
    self:resolve( ... )
    self:super()

    self.tabContainer = self.super.super:addNode( Container() ):set {
        height = "$parent.tabHeight",
        backgroundColour = "$parent.tabBackgroundColour"
    }

    self.leftScrollButton = spawnScrollButton( "<", true, self ):set( "X", "$parent.scroll + 1" )
    self.rightScrollButton = spawnScrollButton( ">", false, self ):set( "X", "$parent.scroll + parent.width" )
end

function TabbedPageContainer:centreActivePageButton( noAnimation )

end

function TabbedPageContainer:updatePagePositions( ... )
    self.super:updatePagePositions( ... )
    self:formTabs()
end

function TabbedPageContainer:selectPage( ... )
    self.super:selectPage( ... )
    self:updateActiveTab()
end

function TabbedPageContainer:updateActiveTab()
    self.tabContainer:query "Button.active":each( function( tab )
        tab:set {
            backgroundColour = "$parent.parent.parent.tabBackgroundColour",
            colour = "$parent.parent.parent.tabColour"
        }

        tab:removeClass "active"
    end )

    if self.selectedPage then
        local selectedTab = self.tabContainer:query( ("Button#%s"):format( self.selectedPage.id ) ).result[ 1 ]
        selectedTab:addClass "active"
        selectedTab.backgroundColour = "$parent.parent.parent.selectedTabBackgroundColour"
        selectedTab.colour = "$parent.parent.parent.selectedTabColour"
    end
end

function TabbedPageContainer:formTabs()
    local tabs, width = {}, 1
    local nodes = self.nodes
    for i = 4, #nodes do
        local page = nodes[ i ]
        local content = page.name or page.id
        local w = ( self.tabPadding * 2 ) + #content

        tabs[ page.position ], width = { content, page.id, w }, width + w
    end

    self.tabContainer:removeNode "innerTabs"
    local container = self.tabContainer:addNode( Container() ):set {
        id = "innerTabs"
    }

    local function spawnTab( text, width, X, page )
        local tab = container:addNode( Button( text ) ):set {
            width = width,
            X = X,
            height = self.tabHeight,
            backgroundColour = "$parent.parent.parent.tabBackgroundColour",
            colour = "$parent.parent.parent.tabColour",
            id = page
        }

        tab:on( "trigger", function() self:selectPage( page ) end )
    end

    local extraSpacePerNode = math.floor( ( self.width - width ) / #tabs )
    if self.smartTabWidth and extraSpacePerNode >= 2 then
        if extraSpacePerNode % 2 ~= 0 then
            extraSpacePerNode = extraSpacePerNode - 1
        end
    else
        extraSpacePerNode = 0
    end

    local widthOverlap = width > self.width
    local canScroll = widthOverlap and self.scrollButtons

    container.X = widthOverlap and "$-parent.parent.tabScroll + 1" or "$parent.width / 2 - ( self.width / 2 ) + .5"
    self:query "Button.scroller":set( "visible", canScroll )
    self.tabContainer:set {
        X = "$parent.scroll + " .. ( canScroll and "2" or "1" ),
        width = "$parent.width - " .. ( canScroll and "2" or "0" )
    }

    local w = 1
    for i = 1, #tabs do
        local tab = tabs[ i ]
        spawnTab( tab[ 1 ], tab[ 3 ] + extraSpacePerNode, w, tab[ 2 ] )
        w = w + extraSpacePerNode + tab[ 3 ]
    end

    container.width = width + ( extraSpacePerNode * #tabs )
    self:updateActiveTab()
end

function TabbedPageContainer:moveTabs( amount )
    local MAX = self:query "#innerTabs".result[ 1 ].width - self.width + 1
    self:animate( "TAB_SCROLL", "tabScroll", math.min( math.max( self.tabScroll + amount, 0 ), MAX < 1 and 1 or MAX ), 0.2, "inOutQuad")
end

function TabbedPageContainer:linkPage( page )
    page.height, page.Y = "$parent.height - parent.tabHeight", "$parent.tabHeight + 1"
    page:linkProperties( self, "width" )
end

function TabbedPageContainer:unlinkPage( page )
    page:removeDynamicValue "height"
    page:unlinkProperties( self, "width" )
end

configureConstructor {
    argumentTypes = {
        tabHeight = "number",
        autoTabWidth = "boolean",
        tabBackgroundColour = "colour",
        tabColour = "colour",
        selectedTabBackgroundColour = "colour",
        selectedTabColour = "colour",
        tabScroll = "number",
        scrollButtons = "boolean"
    }
}
