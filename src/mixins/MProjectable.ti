--[[
    WIP
]]

abstract class MProjectable {
    projectX = false;
    projectY = false;

    projector = false;
    mirrorProjector = false;
}

function MProjectable:MProjectable()
    self:on("focus", function( self, application )
        self:resolveProjectorFocus()
    end)
end

--[[
    WIP
]]
function MProjectable:resolveProjector()
    local app, p = self.application, self.projector
    if app and p then
        local res = app:getProjector( p )
        self.resolvedProjector = res

        if res then
            res:attachMirror( self )
            self:resolveProjectorFocus()
        end
    end
end

function MProjectable:resolveProjectorFocus()
    local app = self.application
    local f = app and app.focusedNode
    if app and f == self then
        local last = self
        while last do
            if last.resolvedProjector then
                last.resolvedProjector.containsFocus = { f:getCaretInfo( last ) }
                last.resolvedProjector.changed = true
            end

            last = last.parent
        end
    end
end

--[[
    WIP
]]
function MProjectable:updateProjection()
    local projector = self.resolvedProjector
    if not projector then return end

    projector.changed = true
    self.canvas:drawTo( projector.canvas, self.projectX or self.X, self.projectY or self.Y )
end

--[[
    WIP
]]
function MProjectable:setProjector( projector )
    if self.resolvedProjector then
        -- Detach this object as a projector mirror
        self.resolvedProjector:detachMirror( self )
    end

    self.projector = projector
    self:resolveProjector()
end

--[[
    @getter
    WIP
]]
function MProjectable:getResolvedProjector()
    if not self.projector then return end

    if not self.resolvedProjector then
        self:resolveProjector()
    end

    return self.resolvedProjector
end

configureConstructor {
    argumentTypes = {
        projectX = "number",
        projectY = "number",

        projector = "string",
        mirrorProjector = "boolean"
    }
}